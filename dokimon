var filesystem = require('fs'),
    util = require('util'),
    querystring = require('querystring');


/**
 * @param {Object} options
 */
function mergeWithDefaultOptions(options) {
    if(options.url == undefined)
        throw new Error('property url missing from options');
    if(options.port == undefined)
        options.port = 80;
    if(options.headers == undefined)
        options.headers = {};
    if(options.write == undefined)
        options.write = '';
    if(options.method == undefined)
        options.method = 'GET';

    if(typeof options.write != 'string')
        options.write = querystring.stringify(options.write);

    if(options.headers['Content-Length'] == undefined && typeof options.write == 'string')
        options.headers['Content-Length'] = Buffer.byteLength(options.write, 'utf8');

    if(typeof options.url == 'object')
        options.path = querystring.stringify(options.url);
    else
        options.path = options.url;

    if(options.headers['User-Agent'] == undefined)
        options['User-Agent'] = 'node dokimon scraper';

    if(options.timeout == undefined)
        options.timeout = 8000;
}


/** * * * * * * * * * * * * * * * * * * * * * * * *
 * @class {TestManager}
 * @param {Object} config
 * @param {Function} testFinishCallback - Optional
 * * * * * * * * * * * * * * * * * * * * * * * * */
var TestManager = function(config, testFinishCallback) {

    this.index = 0;
    this.successes = [];
    this.fails = [];
    this.tests = [];

    /**
     * Wrapper that makes it possible to handle the
     * message with something other then console.log
     *
     * @param {String} message
     */
    this.log = function(message) {
        if(config.log)
            config.log(message);
        else
            console.log(message);
    };

    /**
     * @param {Test[]} tests
     */
    this.setTests = function(tests) {
        this.tests = tests;
    };

    /**
     * Runs tests starting from current position of this.index
     */
    this.run = function() {
        if(config.verbose)
            this.log('Running scripts starting from '+this.index);

        for(var i=this.index; i < this.tests.length; i++) {
            // blocking request
            if(this.tests[i].blocking) {
                if(config.verbose)
                    this.log('Blocking upcoming tests on index '+i+' for '+this.tests[i].name);

                this.index = i+1;
                var self = this;
                this.tests[i].execute(config.host, this, config.verbose, function() {
                    self.run();
                });
                break;
            }
            else
                this.tests[i].execute(config.host, this, config.verbose);
        }
    };

    /**
     * Run a specific test in the test list
     *
     * @param {String} testName
     * @param {Boolean} verbose - Optional
     */
    this.runTest = function(testName, verbose) {
        for(var i=0; i < this.tests.length; i++) {
            if(this.tests[i].name == testName) {
                this.tests[i].execute(config.host, this, config.verbose);
                return;
            }
        }

        throw new Error('Test not found');
    };

    /**
     * @param {Object} success
     */
    this.registerSuccessfullTest = function(success) {
        this.successes.push(success);
        this.log('* '+success.name + ' successfull');
        _checkIfFinished(this);
    };

    /**
     * @param {Object} fail
     * @param {Error} err - Optional
     */
    this.registerFailedtest = function(fail, err) {
        this.fails.push(fail);
        this.log('- '+fail.name + " FAILED! \n"+fail.message);
        if(err)
            this.log(err);
        this.log('');
        _checkIfFinished(this);
    };

    /**
     * Get the correct path to script. Throws error if not exists
     *
     * @param {String} name
     * @return {String}
     */
    this.scriptNameToPath = function(name) {
        var testFileName = name.substring(0, config.testdir.length) == config.testdir ? name : config.testdir+'/'+name;
        if(!_hasDokimonExtension(testFileName))
            testFileName += TestManager.TEST_EXTENSION;

        return testFileName;
    };

    /**
     * Get a list of all available scripts in given directory
     *
     * @param {String} path
     * @return {Array}
     */
    this.loadScriptsInDir = function(path) {
        var scripts = [];
        filesystem.readdirSync(path).forEach(function(f) {
            if(_hasDokimonExtension(f))
                scripts.push(f.substr(0, f.length - TestManager.TEST_EXTENSION.length));
        });
        return scripts;
    };

    /**
     * Will output test result to client when test i finished
     *
     * @access private
     * @param {TestManager} manager
     */
    var _checkIfFinished = function(manager) {
        if(manager.tests.length == (manager.successes.length + manager.fails.length)) {
            if(manager.fails.length == 0) {
                manager.log("\n------------------------------\nEverything is fine :)");
                manager.log('Executed a total of '+manager.successes.length+' successfull tests');
            }
            else {
                manager.log("\n------------------------------\nAll is not well :(");
                manager.log(manager.successes.length+' test'+(manager.successes.length > 1 ? 's':'')+' was successfull');
                manager.log(manager.fails.length+' test'+(manager.fails.length > 1 ? 's':'')+' failed');
                for(var i=0; i < manager.fails.length; i++)
                    manager.log("  - "+manager.fails[i].name+" ("+manager.fails[i].message+")");
            }

            manager.log("");
            if(typeof testFinishCallback == 'function')
                testFinishCallback(manager);
        }
    };

    /**
     * @access private
     * @param {String} path
     * @return {Boolean}
     */
    var _hasDokimonExtension = function(path) {
        return path.substr(-1 * TestManager.TEST_EXTENSION.length) == TestManager.TEST_EXTENSION;
    };
};


/**
 * Extension for scripts containing tests
 */
TestManager.TEST_EXTENSION = '.dokimon';


/** * * * * * * * * * * * * * * * * * * * * * * * *
 * @class {Test}
 * @param {String} testName - Name of this test
 * @param {Object} options - requires url, optional is port:Number, method:String, write:String and headers:Object
 * @param {Function} callback - function(response, body)
 * @param {Boolean} blocking - Optional, whether or not this test is supposed to finish before running any other tests
 * * * * * * * * * * * * * * * * * * * * * * * * */
var Test = function(testName, options, callback, blocking) {

    mergeWithDefaultOptions(options);

    this.blocking = blocking;
    this.name = testName;

    /**
     * @param {TestManager} manager
     * @param {Boolean} verbose - Optional
     * @param {Function} exeFinishCallback - Optional, will be called when request is finished and test callback is called
     */
    this.execute = function(host, manager, verbose, exeFinishCallback) {

        options.host = host;

        if(verbose)
            manager.log("About to request "+host+" for \n"+JSON.stringify(options).replace(/\,\"/g, ",\n\"")+"\n");

        var self = this;

        var req = require('http').request(options, function(res) {
            var collectedBody = '';
            res.setEncoding('utf8');
            res.on('data', function (body) {
                collectedBody += body;
            });
            res.on('end', function() {
                if(res.headers.Location != undefined) {

                    if(res.headers['Set-Cookie'] != undefined)
                        options.headers['Get-Cookie'] = res.headers['Set-Cookie'];

                    options.method = 'GET';
                    options.headers['Content-Length'] = Buffer.byteLength('', 'utf8');
                    options.write = '';
                    options.path = res.headers.Location;

                    self.execute(options.host, options, verbose, exeFinishCallback);
                }
                else {
                    try {
                        callback(res, collectedBody, verbose);

                        manager.registerSuccessfullTest({name : testName, message:''});
                        if(typeof exeFinishCallback == 'function')
                            exeFinishCallback();
                    }
                    catch(e) {
                        manager.registerFailedtest({name : testName, message:e.message}, e);
                        if(typeof exeFinishCallback == 'function')
                            exeFinishCallback();
                    }
                }
            });
        });

        req.on('error', function(e) {
            manager.registerFailedtest({name : testName, message:''}, e);
        });

        req.connection.setTimeout(options.timeout, function() {
            manager.registerFailedtest({name: testName, message : 'Timeout after '+options.timeout+' ms'}, '');
            req.abort();
            if(typeof exeFinishCallback == 'function')
                exeFinishCallback();
        });

        req.write(options.write);
        req.end();
    };
};


/** * * * * * * * * * * * * * * * * * * * * * * * *
 * @class {TestFormPost}
 * @param {String} testName - Name of this test
 * @param {Object} options - requires url, optional is port:Number, method:String, write:String and headers:Object
 * @param {Function} callback - function(response, body)
 * @param {Boolean} blocking - Optional, whether or not this test is supposed to finish before running any other tests
 * * * * * * * * * * * * * * * * * * * * * * * * */
var TestFormPost = function(testName, options, callback, blocking) {

    TestFormPost.super_.call(this, testName, options, callback, blocking);

    options.headers['Content-Type'] = 'application/x-www-form-urlencoded';
    if(typeof(options.write) == 'object')
        options.write = querystring.stringify(options.write);

    options.headers['Content-Length'] = Buffer.byteLength(options.write, 'utf8');

    options.method = 'POST';
};
util.inherits(TestFormPost, Test);


module.exports = {

    /**
     * @param {Object} config
     * @return {TestManager}
     */
    TestManager :  TestManager,

    /**
     * @return {Test}
     */
    Test : Test,

    /**
     * @return {TestFormPost}
     */
    TestFormPost: TestFormPost,

    /**
     * @param {Test} t
     */
    runTest : function(t, config, testFinishCallback) {
        var manager = new TestManager(config, testFinishCallback);
        manager.setTests([t]);
        manager.run();
    },

    TEST_EXTENSION : TestManager.TEST_EXTENSION
};